// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid
{
    float3 position;
    float3 velocity;
    float noiseOffset;
};

//Time values
float _Time;
float _DeltaTime;

//Boid values
RWStructuredBuffer<Boid> _BoidsBuffer;
int _BoidsCount;
float _RotationSpeed;
float _BoidSpeed;
float _NeighbourDistance;
float _BoidSpeedVariation;
float3 _FlockPosition;

[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //Cache boid
    Boid boid = _BoidsBuffer[id.x];

    float3 seperation = 0;
    float3 alignment = 0;
    float3 cohesion = _FlockPosition;

    //Default 1 because of self
    uint nearbyCount = 1;

    //Check for nearby boids
    for (uint i = 0; i < (uint)_BoidsCount; ++i)
    {
        //Pass if boid is self
        if (i == id.x) continue;

        //Cache current boid
        Boid currentBoid = _BoidsBuffer[i];

        //Check distance between our boid and nearby boid
        float dist = distance(boid.position, currentBoid.position);

        //If too close
        if (dist < _NeighbourDistance)
        {
            //Calculate Seperation
            float3 offset = boid.position - currentBoid.position;
            //Ensure distance isn't zero
            dist = max(dist, 0.000001); 
            //If boid is close, increase seperation vector 
            seperation += offset * (1.0 / dist - 1.0 / _NeighbourDistance);

            //Get the sum of each boids direction
            alignment += currentBoid.velocity;

            //Get the sum of each boids position
            cohesion += currentBoid.position;

            //Add one to count of nearby boids
            nearbyCount += 1;
        }
    }

    //Calculate average value of alignment and cohesion
    float avg = 1.0 / nearbyCount;

    alignment *= avg;
    cohesion *= avg;
    cohesion = normalize(cohesion - boid.position);

    //Target direction is sum of all 3 values
    float3 targetDirection = alignment + seperation + cohesion;

    //Lerp towards target direction
    boid.velocity = lerp(normalize(boid.velocity), targetDirection, 0.01);

    //Apply force
    boid.position += (boid.velocity * _BoidSpeed * _DeltaTime);

    //Apply updates back to buffer
    _BoidsBuffer[id.x] = boid;
}