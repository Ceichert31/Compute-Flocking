// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid
{
    float3 position;
    float3 velocity;
    float noiseOffset;
    float frame;
	float3 padding;
};

struct DebugData
{
    float3 position;
    float3 velocity;
    float sampledTerrainHeight;
    float groundDistance;
    float isAvoiding;
    float radius;
};

RWStructuredBuffer<DebugData> _debugBuffer;

//Time values
float _time;
float _deltaTime;

//Boid values
RWStructuredBuffer<Boid> _boidsBuffer;
int _boidsCount;
float _rotationSpeed;
float _boidSpeed;
float _neighborDistance;
float _boidSpeedVariation;
float3 _flockPosition;
float _maxSeparationSpeed;

//Terrain values
Texture2D<float4> _heightMap;
SamplerState sampler_heightMap;
float _heightmapResolution;
float3 _terrainSize;
float3 _terrainPosition;
float _avoidanceDistance;
float _maxHeight;

//Weights
float _alignmentWeight;
float _cohesionWeight;
float _separationWeight;
float _avoidanceWeight;
float _correctionWeight;

//Animation values
float _boidFrameSpeed;
int _numberOfFrames;

//Sphere detection
float _maximumRadius;
float3 _sphereCenter;

//Returns whether point is within bounds
bool InsideBounds(float3 currentPos)
{
    float xValue = pow(currentPos.x - _sphereCenter.x, 2);
    float yValue = pow(currentPos.y - _sphereCenter.y, 2);
    float zValue = pow(currentPos.z - _sphereCenter.z, 2);

    if (xValue + yValue + zValue <= pow(_maximumRadius, 2))
    {
        return true;
    }
    return false;
}

float hash( float n )
{
	return frac(sin(n)*43758.5453);
}

// The noise function returns a value in the range -1.0f -> 1.0f
float noise1( float3 x )
{
	float3 p = floor(x);
	float3 f = frac(x);

	f       = f*f*(3.0-2.0*f);
	float n = p.x + p.y*57.0 + 113.0*p.z;

	return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),
					lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),
				lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
					lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
}

float GetTerrainHeight(float3 worldPos)
{
    //Convert from world space to UV coord space
    float2 uv = (worldPos.xz - _terrainPosition.xz) / _terrainSize.xz;
    
    //Sample height value from heightmap 
    float height = _heightMap.SampleLevel(sampler_heightMap, uv, 0).r;
    
    //Convert back to world space and return
    return height * _terrainSize.y * 2.0 + _terrainPosition.y;
}

[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //Cache boid
    Boid boid = _boidsBuffer[id.x];

    DebugData debugData;

    float3 separation = float3(0,0,0);
    float3 alignment = float3(0,0,0);
    float3 cohesion = float3(0,0,0);
    float3 groundAvoidance = float3(0,0,0);

    //Calculate noise to be used for speed variation
    float noise = clamp(noise1(_time / 100.0 + boid.noiseOffset), -1, 1) * 2.0 - 1.0;
    
    //Use noise to determine velocity
    float velocity = _boidSpeed * (1.0 + noise * _boidSpeedVariation);

    //Default 1 because of self
    uint nearbyCount = 0;
    
    //Sample future positions heightmap
    float sampledHeight = GetTerrainHeight(boid.position);

    //Calculate distance from ground
    float groundDist = (boid.position.y - sampledHeight);
    
    debugData.groundDistance = groundDist;
    debugData.sampledTerrainHeight = sampledHeight;
    debugData.isAvoiding = 0;
    
    //If too close to ground, increase avoidance
    if (groundDist < _avoidanceDistance)
    {
        float avoidanceStrength = (_avoidanceDistance - groundDist) / _avoidanceDistance;
        groundAvoidance += float3(0, 1, 0) * avoidanceStrength * _avoidanceWeight;
        debugData.isAvoiding = 1;
    }
    
    float3 centerOfMass = float3(0,0,0);
    
    //Check for nearby boids
    for (uint i = 0; i < (uint)_boidsCount; i++)
    {
        //Skip self
        if (i == id.x) continue;
        
        //Calculate the direction from our boid to other boid
        float3 direction = _boidsBuffer[i].position - boid.position;

        //Cache the length of the direction vector
        float distance = max(length(direction), 0.000001);
        
        //If within neighboring distance
        if (distance <= _neighborDistance)
        {
            //If boid is close, increase separation vector 
            separation += -normalize(direction) * (1.0 - (distance / _neighborDistance));
            
            //Get the sum of each boids velocity
            alignment += _boidsBuffer[i].velocity;

            //Get the sum of each boids position
            centerOfMass += _boidsBuffer[i].position;
            
            //Add one to count of nearby boids
            nearbyCount++;
        }
    }

    debugData.radius = _neighborDistance;

    if (nearbyCount > 0)
    {
        alignment /= nearbyCount;
        centerOfMass /= nearbyCount;
        cohesion = normalize(centerOfMass - boid.position);
        if (length(cohesion) < 0.1f)
        {
            cohesion = float3(0,0,0);
        }
    }
    else
    {
        alignment = boid.velocity;
    }

    //Apply weights
    separation = (separation * _separationWeight);
    alignment = (alignment * _alignmentWeight);
    cohesion = (cohesion * _cohesionWeight);
    groundAvoidance = (groundAvoidance * _avoidanceWeight);

    //Clamp magnitude of separation
    if (length(separation) > _maxSeparationSpeed)
    {
        separation = normalize(separation) * _maxSeparationSpeed; 
    }
    
    //Final weighted movement force
    float3 finalForce = cohesion + alignment + separation + groundAvoidance;

    //Lerp towards target direction
    boid.velocity = lerp(normalize(boid.velocity), finalForce, _rotationSpeed);

    //Set position
    boid.position += (boid.velocity * velocity * _deltaTime);

    if (!InsideBounds(boid.position))
    {
        float3 outwardDirection = -normalize(boid.position - _sphereCenter);

        boid.position = _sphereCenter + outwardDirection * (_maximumRadius - 15);

        boid.velocity = reflect(boid.velocity, outwardDirection);
    }
    
    //Update animation
    boid.frame = boid.frame + velocity * _deltaTime * _boidFrameSpeed;
    
    boid.frame %= _numberOfFrames;
    debugData.velocity = boid.velocity;
    debugData.position = boid.position;
    _debugBuffer[id.x] = debugData;

    //Apply updates back to buffer
    _boidsBuffer[id.x] = boid;
}